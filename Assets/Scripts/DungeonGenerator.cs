using System.Collections;
using System.Collections.Generic;
using System.IO;
using Unity.VisualScripting;
using Unity.VisualScripting.FullSerializer;
using UnityEngine;
using static UnityEngine.UI.Image;

public class DungeonGenerator : MonoBehaviour
{
    [Header("明るさをつける(デバッグ)")]
    [SerializeField] private bool m_isBrightness;

    [Header("ステージ(0〜)")]
    [SerializeField] private int m_stageNum;

    [Header("ダンジョンデータベース")]
    [SerializeField] private DungeonDataBase m_dungeonDataBase;

    [System.Serializable]
    public class BlockOdds
    {
        [Header("種類")]
        public BlockData.BlockType type;       // 種類
        [Header("確率")]
        public int odds;       // 確率
    }

    [Header("核からプレイヤーの出現しない距離")]
    [SerializeField] private int m_playerLength = 35;
    [Header("プレイヤー")]
    [SerializeField] private GameObject m_player;
    [Header("プレイシーンマネージャー")]
    [SerializeField] private PlaySceneManager m_playSceneManager;

    [Header("地面背景")]
    [SerializeField] private GameObject m_ground;

    //コアの位置
    private int m_corePosX;
    private int m_corePosY;
    //プレイヤーの位置
    private Vector2 m_playerPos;
    //ブロックの親
    private GameObject m_parent;

    //ブロック生成スクリプト
    private BlockGenerator m_blockGenerator;



    private void Awake()
    {
        m_blockGenerator = GetComponent<BlockGenerator>();

        m_parent = new GameObject("Blocks");

        Vector2 dungeonSize = m_dungeonDataBase.dungeonDatas[m_stageNum].dungeonSize;

        m_corePosX = Random.Range(0, (int)dungeonSize.x * 10);
        m_corePosY = Random.Range(0, (int)dungeonSize.y * 10);

        int roop_error = 0;

        //プレイヤーとコアの位置が離れるまで繰り返す
        do
        {
            m_playerPos = new Vector2(Random.Range(0, (int)dungeonSize.x * 10), Random.Range(0, (int)dungeonSize.y * 10));

            if (roop_error > 100)
            {
                Debug.Log("コアとプレイヤーが近すぎます。間隔を見直してください");
                break;
            }
            roop_error++;

        }
        while (
        m_playerPos.x < m_corePosX + m_playerLength &&
        m_playerPos.x > m_corePosX - m_playerLength &&
        m_playerPos.y < m_corePosY + m_playerLength &&
        m_playerPos.y > m_corePosY - m_playerLength
        );

        //  プレイヤーの生成
        GameObject pl = Instantiate<GameObject>(m_player, m_playerPos, Quaternion.identity);

        // coreの生成
        GameObject co = m_blockGenerator.GenerateBlock(BlockData.BlockType.CORE, new Vector3(m_corePosX, m_corePosY), null, m_isBrightness);


        //  プレイシーンマネージャーが無かったら格納しない
        if (m_playSceneManager == null)
            Debug.Log("Error:Playerの格納に失敗 PlaySceneManagerが見つかりません:DungeonManager");
        else
        {
            m_playSceneManager.SetPlayer(pl);
            m_playSceneManager.SetCore(co);
        }

        //１０＊１０のリスト管理用
        List<List<List<string>>> mapListManager = new List<List<List<string>>>();

        //データベースからリストの取得
        List<TextAsset> dungeonCSV = m_dungeonDataBase.dungeonDatas[m_stageNum].dungeonCSV;

        for (int i = 0; i < dungeonCSV.Count; i++)
        {
            // ファイルがなければマップ読み込みの処理をしない
            if (dungeonCSV[i] == null)
            {
                Debug.Log("CSV file is not assigned");
                return;

            }

            // マップのリスト
            List<List<string>> mapList = new List<List<string>>();

            // ファイルの内容を1行ずつ処理
            string[] lines = dungeonCSV[i].text.Split('\n');
            foreach (string line in lines)
            {
                string[] values = line.Split(',');

                // 各行のデータを格納するリスト
                List<string> rowData = new List<string>();

                // 各列の値を処理する
                foreach (string value in values)
                {
                    // データをリストに追加
                    rowData.Add(value);
                }

                // 行のデータをCSVデータに追加
                mapList.Add(rowData);
            }


            //３次元に入れる
            mapListManager.Add(mapList);

            // ファイルを閉じる
            //streamReader.Close();

        }

        //ブロック生成
        for (int y = 0; y < (int)dungeonSize.y; y++)
        {
            for (int x = 0; x < (int)dungeonSize.x; x++)
            {
                int random = Random.Range(0, dungeonCSV.Count);
                Make10_10Block(mapListManager[random], x * 10, y * 10);

            }
        }

        //岩盤で囲う
        for (int i = 0; i < (int)dungeonSize.y * 10; i++)
        {
            m_blockGenerator.GenerateBlock(BlockData.BlockType.BEDROCK, new Vector3(-1, i, 0), m_parent.transform, m_isBrightness);
            m_blockGenerator.GenerateBlock(BlockData.BlockType.BEDROCK, new Vector3((int)dungeonSize.y * 10, i, 0), m_parent.transform, m_isBrightness);
        }
        for (int i = 0; i < (int)dungeonSize.x * 10; i++)
        {
            m_blockGenerator.GenerateBlock(BlockData.BlockType.BEDROCK, new Vector3(i, -1, 0), m_parent.transform, m_isBrightness);
            m_blockGenerator.GenerateBlock(BlockData.BlockType.BEDROCK, new Vector3(i, (int)dungeonSize.y * 10, 0), m_parent.transform, m_isBrightness);
        }

        //地面の生成
        for (int y = 0; y < (int)dungeonSize.y * 10; ++y)
        {
            for (int x = 0; x < (int)dungeonSize.x * 10; ++x)
            {
                // 生成座標
                Vector3 pos = new(x, y, 0.0f);

                // ブロックの生成
                GameObject block = Instantiate<GameObject>(m_ground, pos, Quaternion.identity);

                block.transform.parent = m_parent.transform;

            }
        }

    }


    void Make10_10Block(List<List<string>> mapList,int originX, int originY)
    {
        // 読みだしたデータをもとにダンジョン生成をする
        for (int y = 0; y < mapList.Count; y++)
        {
            for (int x = 0; x < mapList[y].Count; x++)
            {
                //プレイヤー
                if((int)m_playerPos.x == x + originX && (int)m_playerPos.y == y + originY)
                {
                    continue;
                }

                //コアを生成
                if(m_corePosX == x + originX && m_corePosY == y + originY)
                {
                    continue;
                }
                // 0 の場合は何も生成しない
                if (mapList[y][x] == "0" || mapList[y][x] == "")
                    continue;

                // 生成座標
                Vector3 pos = new(originX + x,originY + y, 0.0f);

                // ブロックの生成
                m_blockGenerator.GenerateBlock(
                    m_dungeonDataBase.dungeonDatas[m_stageNum].dungeonOdds
                    [LotteryBlock()].type, 
                    pos, 
                    m_parent.transform,
                    m_isBrightness
                    );
            }
        }
    }


    int LotteryBlock()
    {
        //確率の抽選
        List<int> oddsList = new List<int>();

        //全ての確率合算
        int allOdds = 0;

        List<BlockOdds> blockOddsList = m_dungeonDataBase.dungeonDatas[m_stageNum].dungeonOdds;


        //ブロックの種類の数
        for (int i = 0; i < blockOddsList.Count; i++)
        {
            //ブロックの確率
            for (int j = 0; j < blockOddsList[i].odds; j++)
            {
                oddsList.Add(i);
            }
            //ブロックの確率を加算
            allOdds += blockOddsList[i].odds;
        }
        //抽選
        return oddsList[Random.Range(0,allOdds)];
    }


    public int GetStageNum()
    {
        return m_stageNum;
    }
}
